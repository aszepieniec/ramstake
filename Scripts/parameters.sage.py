# This file was *autogenerated* from the file parameters.sage
from sage.all_cmdline import *   # import sage library
_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4); _sage_const_8 = Integer(8); _sage_const_110503 = Integer(110503); _sage_const_60 = Integer(60); _sage_const_1p0 = RealNumber('1.0'); _sage_const_110 = Integer(110); _sage_const_192 = Integer(192); _sage_const_2p0 = RealNumber('2.0'); _sage_const_255 = Integer(255); _sage_const_256 = Integer(256); _sage_const_216091 = Integer(216091); _sage_const_10 = Integer(10); _sage_const_1000 = Integer(1000); _sage_const_1024 = Integer(1024); _sage_const_128 = Integer(128); _sage_const_160 = Integer(160); _sage_const_132049 = Integer(132049); _sage_const_86243 = Integer(86243); _sage_const_44497 = Integer(44497); _sage_const_321 = Integer(321)# run me:
# sage parameters.sage

from numpy import mean, std
from scipy.stats import norm

def SampleSparseInteger( modulus_bitsize, mass ):
    integer = _sage_const_0 
    for i in range(_sage_const_0 , mass):
        integer += _sage_const_1  << (Integers(modulus_bitsize).random_element())
    return integer

class Parameters:
    def __init__( self, modulus_bitsize, security_level, bch_codeword_length, bch_errors_corrigible, rs_codeword_length, rs_errors_corrigible ):
        self.modulus_bitsize = modulus_bitsize
        self.security_level = security_level
        
        self.additive_mass = None
        self.multiplicative_mass = None
        self.bit_errors_mean = None
        self.bit_errors_std = None

        self.bch_codeword_length = bch_codeword_length
        self.bch_corrigible_errors = bch_errors_corrigible

        self.rs_codeword_length = rs_codeword_length
        self.rs_corrigible_errors = rs_errors_corrigible

    def ComputeMasses( self ):
        if self.additive_mass == None or self.multiplicative_mass == None:
            for self.multiplicative_mass in range(_sage_const_0 , self.modulus_bitsize // _sage_const_2 ):
                if log(_sage_const_1p0 *binomial(self.modulus_bitsize, self.multiplicative_mass), _sage_const_2p0 ) >= self.security_level:
                    break
            self.additive_mass = self.security_level - self.multiplicative_mass

    def ComputeStatistics( self, num_trials ):
        p = _sage_const_2 **self.modulus_bitsize - _sage_const_1 
        bit_errors_list = []
        byte_errors_list = []
        for i in range(_sage_const_0 , num_trials):
            g = ZZ(Integers(_sage_const_2 **self.modulus_bitsize).random_element())
            am = SampleSparseInteger(self.modulus_bitsize, self.multiplicative_mass)
            aa = SampleSparseInteger(self.modulus_bitsize, self.additive_mass)
            bm = SampleSparseInteger(self.modulus_bitsize, self.multiplicative_mass)
            ba = SampleSparseInteger(self.modulus_bitsize, self.additive_mass)

            ga = ((am*g + aa)*bm) % p
            gb = ((bm*g + ba)*am) % p

            stra = bin(ga)[_sage_const_2 :]
            strb = bin(gb)[_sage_const_2 :]
            while len(stra) < len(strb):
                stra = '0' + stra
            while len(strb) < len(stra):
                strb = '0' + strb

            num_errors = _sage_const_0 
            for j in range(_sage_const_0 , self.bch_codeword_length):
                if stra[j+_sage_const_8 ] != strb[j+_sage_const_8 ]:
                    num_errors += _sage_const_1 

            bit_errors_list.append(num_errors)

            stra = hex(ga)
            strb = hex(gb)
            while len(stra) != max(len(stra), len(strb)) or len(stra)%_sage_const_2  != _sage_const_0 :
                stra = '0' + stra
            while len(strb) != max(len(stra), len(strb)) or len(strb)%_sage_const_2  != _sage_const_0 :
                strb = '0' + strb

            num_errors = _sage_const_0 
            for j in range(_sage_const_0 , self.rs_codeword_length/_sage_const_8 ):
                if stra[(_sage_const_2 *j+_sage_const_2 ):(_sage_const_2 *j+_sage_const_4 )] != strb[(_sage_const_2 *j+_sage_const_2 ):(_sage_const_2 *j+_sage_const_4 )]:
                    num_errors += _sage_const_1 

            byte_errors_list.append(num_errors)

        self.bit_errors_mean = mean(bit_errors_list)
        self.bit_errors_std = std(bit_errors_list, ddof=_sage_const_1 )

        self.byte_errors_mean = mean(byte_errors_list)
        self.byte_errors_std = std(byte_errors_list, ddof=_sage_const_1 )

    def OptimalRSCodewordNumber( self ):
        if self.byte_errors_mean == None or self.byte_errors_std == None:
            print "compute statistics first"
            return _sage_const_0 

        failure_probability = _sage_const_1p0  - norm.cdf(_sage_const_1p0 *(self.rs_corrigible_errors - self.byte_errors_mean) / self.byte_errors_std)
        #print "failure probability for one codeword: %f " % failure_probability, "with t =", self.rs_corrigible_errors, ", mu =", self.byte_errors_mean, "and sigma =", self.byte_errors_std

        all_fail_probability = _sage_const_1p0 
        number = _sage_const_0 
        for number in range(_sage_const_0 , floor(self.modulus_bitsize / self.rs_codeword_length)+_sage_const_10 ):
            if all_fail_probability <= _sage_const_2 **-_sage_const_60 : #<= 10^(-17):
                break
            all_fail_probability *= failure_probability

        if number * self.rs_codeword_length > self.modulus_bitsize:
            #print "need too many codewords"
            return _sage_const_0 

        return number

    def OptimalBCHCodewordNumber( self ):
        if self.bit_errors_mean == None or self.bit_errors_std == None:
            print "compute statistics first"
            return _sage_const_0 

        failure_probability = _sage_const_1p0  - norm.cdf(_sage_const_1p0 *(self.bch_corrigible_errors - self.bit_errors_mean) / self.bit_errors_std)
        #print "failure probability for one codeword: %f " % failure_probability, "with t =", self.bch_corrigible_errors, ", mu =", self.bit_errors_mean, "and sigma =", self.bit_errors_std

        all_fail_probability = _sage_const_1p0 
        number = _sage_const_0 
        for number in range(_sage_const_0 , floor(self.modulus_bitsize / self.bch_codeword_length)+_sage_const_10 ):
            if all_fail_probability <= _sage_const_2 **-_sage_const_60 : #<= 10^(-17):
                break
            all_fail_probability *= failure_probability

        if number * self.bch_codeword_length > self.modulus_bitsize:
            #print "need too many codewords"
            return _sage_const_0 

        return number

mersenne_primes = [_sage_const_44497 , _sage_const_86243 , _sage_const_110503 , _sage_const_132049 , _sage_const_216091 ]
security_levels = [_sage_const_128 , _sage_const_192 , _sage_const_256 ]
delta = _sage_const_321 
bch_codeword_length = _sage_const_255 *_sage_const_8 #delta*12 + 256
bch_corrigible_errors = _sage_const_160 #(delta-1)/2
rs_codeword_length = _sage_const_255 *_sage_const_8 
rs_corrigible_errors = _sage_const_110 

for p in mersenne_primes:
    for seclvl in security_levels:
        params = Parameters(p, seclvl, bch_codeword_length, bch_corrigible_errors, rs_codeword_length, rs_corrigible_errors)
        params.ComputeMasses()
        params.ComputeStatistics(_sage_const_1000 )

        pubkey_size = seclvl + p

        print "RS:",
        repetitions = params.OptimalRSCodewordNumber()
        ciphertext_size = p + repetitions*rs_codeword_length + seclvl
        print "p = 2^%i-1, sclvl = %i ---> xmass = %i, +mass = %i, mean = %f, std = %f, #codewords = %i, |ctxt| = %f kB, |pk| = %f kB" % (p, seclvl, params.multiplicative_mass, params.additive_mass, params.byte_errors_mean, params.byte_errors_std, repetitions, (_sage_const_1p0 *ciphertext_size)/_sage_const_8 /_sage_const_1024 , _sage_const_1p0 *pubkey_size/_sage_const_8 /_sage_const_1024 )

        print "BCH:",
        repetitions = params.OptimalBCHCodewordNumber()
        ciphertext_size = p + repetitions*bch_codeword_length + seclvl
        print "p = 2^%i-1, sclvl = %i ---> xmass = %i, +mass = %i, mean = %f, std = %f, #codewords = %i, |ctxt| = %f kB, |pk| = %f kB" % (p, seclvl, params.multiplicative_mass, params.additive_mass, params.bit_errors_mean, params.bit_errors_std, repetitions, (_sage_const_1p0 *ciphertext_size)/_sage_const_8 /_sage_const_1024 , _sage_const_1p0 *pubkey_size/_sage_const_8 /_sage_const_1024 )

    print ""

